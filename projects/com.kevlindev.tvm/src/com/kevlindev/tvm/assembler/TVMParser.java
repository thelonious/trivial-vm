package com.kevlindev.tvm.assembler;

import java.util.ArrayList;
import java.util.Map;
import java.io.IOException;
import java.util.HashMap;
import beaver.*;

import com.kevlindev.tvm.Opcode;
import com.kevlindev.tvm.OperandType;
import com.kevlindev.tvm.assembler.model.Address;
import com.kevlindev.tvm.assembler.model.BaseNode;
import com.kevlindev.tvm.assembler.model.Identifier;
import com.kevlindev.tvm.assembler.model.Instruction;
import com.kevlindev.tvm.assembler.model.Number;
import com.kevlindev.tvm.assembler.model.Operand;
import com.kevlindev.tvm.assembler.model.Program;
import com.kevlindev.tvm.assembler.model.Register;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "tvm-assembler.grammar".
 */
public class TVMParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obakTF0a4GnTyT7IdI14HG40jOG4qqccZi7$oh#6FjlHSiuzjb4Wc1JzxcTs$cxSxSNZ8" +
		"0ZaJWnnHcC8S5U0V4LVXGmII2Y6CH3KJX8YR7z8UiNwLlT9WQGHXvf6mUucaFdG3IA2A914" +
		"QPJQE6kYM34MIHmomA64C9POnZ0lC0AuAi3hD$P43ii9k7jupodWdsTlaDX$qSnAplq3SQf" +
		"yPvCuVBv1bxsZYkNJukavczJfsFhiC$S6rD9q$nJiqMNoBIfi34VFogHH8YYPRkgPyZ1Orh" +
		"P8ciaBfwcsI3R95jzPR93jdJV9$iaaDoqDrVzykgQpt#UkzPzGEafB6hMb7DzwlHlUoWlV$" +
		"0fwRQwF5N#vnjTaH#o9V6RRcK2tbXz6pp9$9WeqToJsx9jNLko9MSovdSCVeWxt8g9zGtUP" +
		"LF#UQXWfsYj4wKcQoadJOlSRjmx5IPoUdWKm9T$f#NeMU8Aoab#mk5ssiF");

	private Address createAddress(String text) {
		return new Address(Integer.parseInt(text.substring(1)));
	}

	private Register createRegister(String text) {
		return new Register(Integer.parseInt(text.substring(1)));
	}

	public Program parse(String source) {
		TVMLexer lexer = new TVMLexer();

		lexer.setSource(source);

		Object result = null;

		try {
			result = parse(lexer);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return (result instanceof Program) ? (Program) result : null;
	}

	public TVMParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Grammar = Statements.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final beaver.Symbol[] s = _list_s == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_s.toArray(new beaver.Symbol[_list_s.size()]);
					
			return new Program(_list_s);
			}
			case 1: // Statements = Statements StatementWithLabel
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 2: // Statements = StatementWithLabel
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 3: // StatementWithLabel = LABEL.l Statement.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Instruction s = (Instruction) _symbol_s.value;
					
			s.setLabel(l.substring(1));

			return s;
			}
			case 5: // Statement = SET Container.c COMMA Source.s
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Operand c = (Operand) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Operand s = (Operand) _symbol_s.value;
					
			return new Instruction(Opcode.SET, c, s);
			}
			case 6: // Statement = INC Container.c
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Operand c = (Operand) _symbol_c.value;
					
			return new Instruction(Opcode.INC, c);
			}
			case 7: // Statement = JEQ Destination.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final Operand d = (Operand) _symbol_d.value;
					
			return new Instruction(Opcode.JEQ, d);
			}
			case 8: // Statement = JNE Destination.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final Operand d = (Operand) _symbol_d.value;
					
			return new Instruction(Opcode.JNE, d);
			}
			case 9: // Statement = BRK
			{
					
			return new Instruction(Opcode.BRK);
			}
			case 10: // Container = Location.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final BaseNode l = (BaseNode) _symbol_l.value;
					
			return new Operand(OperandType.ADDRESS, l);
			}
			case 11: // Container = Location.l PLUS REGISTER.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final BaseNode l = (BaseNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDEXED, l, createRegister(r));
			}
			case 12: // Container = LBRACKET Location.l RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final BaseNode l = (BaseNode) _symbol_l.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT, l);
			}
			case 13: // Container = LBRACKET Location.l PLUS REGISTER.r RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final BaseNode l = (BaseNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 4];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT_PRE_INDEXED, l, createRegister(r));
			}
			case 14: // Container = LBRACKET Location.l RBRACKET PLUS REGISTER.r
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final BaseNode l = (BaseNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT_POST_INDEXED, l, createRegister(r));
			}
			case 15: // Container = LBRACKET Location.l PLUS REGISTER.r1 RBRACKET PLUS REGISTER.r2
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final BaseNode l = (BaseNode) _symbol_l.value;
					final Symbol _symbol_r1 = _symbols[offset + 4];
					final String r1 = (String) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 7];
					final String r2 = (String) _symbol_r2.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT_PRE_AND_POST_INDEXED, l, createRegister(r1), createRegister(r2));
			}
			case 16: // Container = REGISTER.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.REGISTER, createRegister(r));
			}
			case 17: // Container = LBRACKET REGISTER.r RBRACKET
			{
					final Symbol _symbol_r = _symbols[offset + 2];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.REGISTER_INDIRECT, createRegister(r));
			}
			case 18: // Container = LBRACKET REGISTER.r1 PLUS REGISTER.r2 RBRACKET
			{
					final Symbol _symbol_r1 = _symbols[offset + 2];
					final String r1 = (String) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 4];
					final String r2 = (String) _symbol_r2.value;
					
			return new Operand(OperandType.REGISTER_INDIRECT_PRE_INDEXED, createRegister(r1), createRegister(r2));
			}
			case 19: // Container = LBRACKET REGISTER.r1 RBRACKET PLUS REGISTER.r2
			{
					final Symbol _symbol_r1 = _symbols[offset + 2];
					final String r1 = (String) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 5];
					final String r2 = (String) _symbol_r2.value;
					
			return new Operand(OperandType.REGISTER_INDIRECT_POST_INDEXED, createRegister(r1), createRegister(r2));
			}
			case 20: // Container = LBRACKET REGISTER.r1 PLUS REGISTER.r2 RBRACKET PLUS REGISTER.r3
			{
					final Symbol _symbol_r1 = _symbols[offset + 2];
					final String r1 = (String) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 4];
					final String r2 = (String) _symbol_r2.value;
					final Symbol _symbol_r3 = _symbols[offset + 7];
					final String r3 = (String) _symbol_r3.value;
					
			return new Operand(OperandType.REGISTER_INDIRECT_PRE_AND_POST_INDEXED, createRegister(r1), createRegister(r2), createRegister(r3));
			}
			case 22: // Source = NUMBER.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			return new Operand(OperandType.NUMBER, new Number(Integer.parseInt(n.substring(1))));
			}
			case 23: // Location = ADDRESS.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					
			return createAddress(a);
			}
			case 24: // Location = IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					
			return new Identifier(i);
			}
			case 25: // Destination = ADDRESS.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					
			return new Operand(OperandType.ADDRESS, createAddress(a));
			}
			case 26: // Destination = IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					
			return new Operand(OperandType.LABEL, new Identifier(i));
			}
			case 4: // StatementWithLabel = Statement
			case 21: // Source = Container
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
