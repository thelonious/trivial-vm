package com.kevlindev.tvm.assembler;

import java.util.ArrayList;
import com.kevlindev.tvm.assembler.ast.OperandType;
import com.kevlindev.tvm.assembler.ast.Opcode;
import beaver.*;
import com.kevlindev.tvm.assembler.ast.Operand;
import com.kevlindev.tvm.assembler.ast.Instruction;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "tvm-assembler.grammar".
 */
public class TVMParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9o5aLbJma0GX7iJY22O4n2Gg1HQMFhaF#G7Uw1oAA9ZxsP81HzWgxxftjbZzW3mA880VGn" +
		"nMMeTjTAVq5$X6XwZBqyuHnlHNZn51osCq4G32SuG8aMC35tqa6E02u0x1jofKQfTjVCXVS" +
		"GLYOiT6DRozsB8CxJfKjPfqXlYCHhsRBsC5SOpk1ROOBs8R3Kt84FIc#cOvYTaglwEvEIMt" +
		"6lkWTnKvezKnzLz$iFcsHlh6JQQCwhfeRN7gDmpFpId4FabM$KRcSkhhEYMhhyWxyvzo1lZ" +
		"5$cK5tcMjNpB3mSoznS9RvDGOsfCZVZs4Ns1uUjRVAMk6FvLGQPq$m0QTarD");

	public TVMParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 1: // Statements = Statements StatementWithLabel
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 2: // Statements = StatementWithLabel
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 3: // StatementWithLabel = LABEL.l Statement.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Instruction s = (Instruction) _symbol_s.value;
					
			s.setLabel(l);
			
			return s;
			}
			case 5: // Statement = LOAD Container.c COMMA Source.s
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Operand c = (Operand) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Operand s = (Operand) _symbol_s.value;
					
			return new Instruction(Opcode.LOAD, c, s);
			}
			case 6: // Statement = INC Container.c
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final Operand c = (Operand) _symbol_c.value;
					
			return new Instruction(Opcode.INC, c);
			}
			case 7: // Statement = BNE Destination.d
			{
					final Symbol _symbol_d = _symbols[offset + 2];
					final Operand d = (Operand) _symbol_d.value;
					
			return new Instruction(Opcode.BNE, d);
			}
			case 8: // Statement = BRK
			{
					
			return new Instruction(Opcode.BRK);
			}
			case 9: // Container = ADDRESS.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					
			return new Operand(OperandType.ADDRESS, a);
			}
			case 10: // Container = ADDRESS.a PLUS REGISTER.r
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDEXED, a, r);
			}
			case 11: // Container = LBRACKET ADDRESS.a RBRACKET
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final String a = (String) _symbol_a.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT, a);
			}
			case 12: // Container = LBRACKET ADDRESS.a PLUS REGISTER.r RBRACKET
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final String a = (String) _symbol_a.value;
					final Symbol _symbol_r = _symbols[offset + 4];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT_PRE_INDEXED, a, r);
			}
			case 13: // Container = LBRACKET ADDRESS.a RBRACKET PLUS REGISTER.r
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final String a = (String) _symbol_a.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.ADDRESS_INDIRECT_POST_INDEXED, a, r);
			}
			case 14: // Container = REGISTER.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final String r = (String) _symbol_r.value;
					
			return new Operand(OperandType.REGISTER, r);
			}
			case 16: // Source = NUMBER.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			return new Operand(OperandType.NUMBER, n);
			}
			case 17: // Destination = ADDRESS.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					
			return new Operand(OperandType.ADDRESS, a);
			}
			case 18: // Destination = IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					
			return new Operand(OperandType.LABEL, i);
			}
			case 0: // Grammar = Statements
			case 4: // StatementWithLabel = Statement
			case 15: // Source = Container
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
