package com.kevlindev.template.parser;

import java.util.ArrayList;
import java.util.Map;
import beaver.*;
import java.util.List;
import java.util.HashMap;
import java.io.IOException;

import com.kevlindev.template.parser.model.TemplateNode;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "token.grammar".
 */
public class TemplateParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9nzKDSEmZ0Cl9JIqZs03ea7FhNVp2hRN8DLLHKYqequFainWBq85bZ2XOyGsr4RbF3We9G" +
		"3DaYnHeQSl4A2015Y5AXGymRs6yvmESKRDMJMuQl3NCHKm1a36yvto36h0$lCjntiSGTIRu" +
		"X8VKNKwbkYK1#g9ftcfk3P4SsiPaIa$zK$wyjKFTNYJsyvyUrNv6tvQVbX#KvSYLukSfAZd" +
		"6tr9g$X1zoIiTjAg26tE4NCUanDgIdV8qN#0IsDC#0=");

	public TemplateNode parse(String source) {
		TemplateLexer lexer = new TemplateLexer();

		lexer.setSource(source);

		Object result = null;

		try {
			result = parse(lexer);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return (result instanceof TemplateNode) ? (TemplateNode) result : null;
	}

	public TemplateParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Grammar = Statements.ss
			{
					final Symbol _symbol_ss = _symbols[offset + 1];
					final List<TemplateNode> ss = (List<TemplateNode>) _symbol_ss.value;
					
			TemplateNode result = new TemplateNode(TemplateTokenType.ROOT);
			
			result.addChildren(ss);
			
			return new Symbol(result);
			}
			case 1: // Statements = Statements.ss Statement.s
			{
					final Symbol _symbol_ss = _symbols[offset + 1];
					final List<TemplateNode> ss = (List<TemplateNode>) _symbol_ss.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final TemplateNode s = (TemplateNode) _symbol_s.value;
					
			ss.add(s);
			
			return new Symbol(ss);
			}
			case 2: // Statements = Statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final TemplateNode s = (TemplateNode) _symbol_s.value;
					
			List<TemplateNode> result = new ArrayList<TemplateNode>();
			
			result.add(s);
			
			return new Symbol(result);
			}
			case 3: // Statement = PACKAGE.p EQUAL IDENTIFIER.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					
			TemplateNode result = new TemplateNode(p);
			
			result.addChild(new TemplateNode(i));
			
			return result;
			}
			case 4: // Statement = LANGUAGE.l EQUAL IDENTIFIER.i
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					
			TemplateNode result = new TemplateNode(l);
			
			result.addChild(new TemplateNode(i));
			
			return result;
			}
			case 5: // Statement = KEYWORDS.k EQUAL List.l
			{
					final Symbol k = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List<TemplateNode> l = (List<TemplateNode>) _symbol_l.value;
					
			TemplateNode result = new TemplateNode(k);
			
			result.addChildren(l);
			
			return result;
			}
			case 6: // Statement = OPERATORS.o EQUAL List.l
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List<TemplateNode> l = (List<TemplateNode>) _symbol_l.value;
					
			TemplateNode result = new TemplateNode(o);
			
			result.addChildren(l);
			
			return result;
			}
			case 7: // List = LBRACKET RBRACKET
			{
					
			return new Symbol(new ArrayList<TemplateNode>());
			}
			case 8: // List = LBRACKET Identifiers.i RBRACKET
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final List<TemplateNode> i = (List<TemplateNode>) _symbol_i.value;
					
			return new Symbol(i);
			}
			case 9: // Identifiers = Identifiers.is Word.w
			{
					final Symbol _symbol_is = _symbols[offset + 1];
					final List<TemplateNode> is = (List<TemplateNode>) _symbol_is.value;
					final Symbol _symbol_w = _symbols[offset + 2];
					final TemplateNode w = (TemplateNode) _symbol_w.value;
					
			is.add(w);
			
			return new Symbol(is);
			}
			case 10: // Identifiers = Word.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final TemplateNode w = (TemplateNode) _symbol_w.value;
					
			List<TemplateNode> result = new ArrayList<TemplateNode>();
			
			result.add(w);
			
			return new Symbol(result);
			}
			case 11: // Word = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new TemplateNode(i);
			}
			case 12: // Word = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new TemplateNode(s);
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
