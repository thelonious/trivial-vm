package com.kevlindev.mcpu.assembler;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import beaver.Parser;
import beaver.ParsingTables;
import beaver.Symbol;

import com.kevlindev.mcpu.Opcode;
import com.kevlindev.mcpu.assembler.model.BaseNode;
import com.kevlindev.mcpu.assembler.model.DataByte;
import com.kevlindev.mcpu.assembler.model.Instruction;
import com.kevlindev.mcpu.assembler.model.Program;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "mcpu-assembler.grammar".
 */
public class MCPUParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9nza5aFWZ0GXASLkQo08lZcaVX3#SkUUA$JqYSYRFDr9kdi9bq01n5C4I962eCCmO1VeK8" +
		"9ZLoEz1Cii7H4I33370N0fEPBuEP50pvbsZ2V8NS#Phz5#MCufsxWAhINzyRhnklMwyxhtc" +
		"j9giRt$OELaDnw4Md7ihsUzSXxtObyoPiyoOFSIKjkSfMpdEGYB$amQF#lk0TD5FUWYN8Rx" +
		"9Cvx6OwYX$8k3Jo");

	private Map<String, BaseNode> labels = new HashMap<String, BaseNode>();
	
	public void addLabel(String label, BaseNode node) {
		labels.put(label, node);
	}

	public Map<String, BaseNode> getLabels() {
		return labels;
	}

	public Program parse(String source) {
		MCPULexer lexer = new MCPULexer();

		lexer.setSource(source);

		Object result = null;

		try {
			result = parse(lexer);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}

		return (result instanceof Program) ? (Program) result : null;
	}

	public MCPUParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Grammar = Statements.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final beaver.Symbol[] s = _list_s == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_s.toArray(new beaver.Symbol[_list_s.size()]);
					
			Program result = new Program(labels);
			
			result.addChildren(_list_s);
			
			return result;
			}
			case 1: // Statements = Statements StatementWithLabel
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 2: // Statements = StatementWithLabel
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 3: // StatementWithLabel = LABEL.l Statement.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final BaseNode s = (BaseNode) _symbol_s.value;
					
			String label = l.substring(0, l.length() - 1);
			
			s.setLabel(label);
			labels.put(label, s);
			
			return s;
			}
			case 5: // Statement = NOR IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new Instruction(Opcode.NOR, i);
			}
			case 6: // Statement = ADD IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new Instruction(Opcode.ADD, i);
			}
			case 7: // Statement = STA IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new Instruction(Opcode.STA, i);
			}
			case 8: // Statement = JCC IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new Instruction(Opcode.JCC, i);
			}
			case 9: // Statement = DB Numbers.ns
			{
					final Symbol _symbol_ns = _symbols[offset + 2];
					final ArrayList _list_ns = (ArrayList) _symbol_ns.value;
					final beaver.Symbol[] ns = _list_ns == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_ns.toArray(new beaver.Symbol[_list_ns.size()]);
					
			DataByte result = new DataByte();
			
			for (Symbol o : ns) {
				Integer i = (Integer) o.value;
				result.addByte(i.intValue());
			}
			
			return result;
			}
			case 10: // Numbers = Numbers Number
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 11: // Numbers = Number
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 12: // Number = NUMBER.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			return new Symbol(Integer.parseInt(n));
			}
			case 13: // Number = HEX.h
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final String h = (String) _symbol_h.value;
					
			return new Symbol(Integer.parseInt(h.substring(2), 16));
			}
			case 4: // StatementWithLabel = Statement
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
